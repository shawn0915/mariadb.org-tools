#!/bin/bash
#===============================================================================
#
#          FILE: prep
# 
#         USAGE: ./prep
# 
#   DESCRIPTION: This script exists so that I don't need to remember or look up
#                where things are when it is time to prepare a release. It also
#                ensures no steps are forgotten, and prevents many errors.
# 
#       OPTIONS: ---
#  REQUIREMENTS: ---
#          BUGS: ---
#         NOTES: ---
#        AUTHOR: Daniel Bartholomew (db), dbart@mariadb.org
#  ORGANIZATION: 
#       CREATED: 03/16/2015 20:37
#      REVISION:  ---
#===============================================================================

umask 002

#killall gpg-agent

set -eu
  # -e  Exit immediately if a simple command exits with a non-zero status,
  #     unless the command that fails is part of an until or  while loop, part
  #     of an if statement, part of a && or || list, or if the command's return
  #     status is being inverted using !.  -o errexit
  #
  # -u  Treat unset variables as an error when performing parameter expansion.
  #     An error message will be written to the standard error, and a
  #     non-interactive shell will exit.
  #
  # -x  Print a trace of simple commands and their arguments after they are
  #     expanded and before they are executed.

#-------------------------------------------------------------------------------
# Options below this point you probably don't need to change
#-------------------------------------------------------------------------------

# Various miscellaneous options
rsync_opts="-a -L --info=progress2"

# set location of prep.conf and prep.log to XDG-compatible directories and then
# create them if they don't exist
dir_conf=${XDG_CONFIG_HOME:-~/.config}
dir_log=${XDG_DATA_HOME:-~/.local/share}

if [ ! -d ${dir_conf}/ ];then
  mkdir -vp ${dir_conf}
fi

if [ ! -d ${dir_log}/ ];then
  mkdir -vp ${dir_log}
fi




#-------------------------------------------------------------------------------
#  The ${build_dirs} option contains two-part names of various bintar builds
#  separated by a colon. The first part is the name of the directory that
#  buildbot saves, the second part is the name we use on the mirrors.
#-------------------------------------------------------------------------------
#build_dirs="kvm-bintar-centos5-amd64:bintar-linux-x86_64 kvm-bintar-centos5-x86:bintar-linux-x86 kvm-bintar-hardy-amd64:bintar-linux-hardy-x86_64 kvm-bintar-hardy-x86:bintar-linux-hardy-x86 kvm-bintar-quantal-amd64:bintar-linux-glibc_214-x86_64 kvm-bintar-quantal-x86:bintar-linux-glibc_214-x86 kvm-tarbake-jaunty-x86:source sol10-64:bintar-sol10-64 bsd9-64:bintar-bsd9-64 opensolaris-511-bintar:bintar-opensolaris-511"

# Sunanda Menon : 02/27/2015
# Splitting build dirs (refer ME-91). 
# Enterprise builds need to grab only Linux 64bit, no 32bit builds
build_dirs_x86="kvm-bintar-centos5-x86:bintar-linux-x86
                kvm-bintar-centos6-x86:bintar-linux-x86
                kvm-bintar-quantal-x86:bintar-linux-glibc_214-x86
                kvm-bintar-trusty-x86:bintar-linux-systemd-x86"

build_dirs_x86_64="kvm-bintar-centos5-amd64:bintar-linux-x86_64
                   kvm-bintar-centos6-amd64:bintar-linux-x86_64
                   kvm-bintar-quantal-amd64:bintar-linux-glibc_214-x86_64
                   kvm-bintar-trusty-amd64:bintar-linux-systemd-x86_64
                   kvm-tarbake-jaunty-x86:source
                   sol10-64:bintar-sol10-64
                   mac-1012-pkg:macOS
                   bsd9-64:bintar-bsd9-64
                   opensolaris-511-bintar:bintar-opensolaris-511"

## Enterprise builds should not build solaris10 for now
ent_build_dirs_x86_64="kvm-bintar-centos5-amd64:bintar-linux-x86_64
                       kvm-bintar-quantal-amd64:bintar-linux-glibc_214-x86_64
                       kvm-tarbake-jaunty-x86:source
                       bsd9-64:bintar-bsd9-64
                       opensolaris-511-bintar:bintar-opensolaris-511"

p8_build_dirs="p8-rhel6-bintar:bintar-linux-rhel6-ppc64
               p8-rhel7-bintar:bintar-linux-rhel7-ppc64
               p8-rhel71-bintar:bintar-linux-rhel71-ppc64le
               p8-trusty-bintar:bintar-linux-trusty-ppc64le
               p8-xenial-bintar:bintar-linux-xenial-ppc64le"

# defaults (to prevent errors)
    displayusage="no"
log_displayusage=""
            demo="no"
        log_demo=""
      run_script="no"
  log_run_script=""
          is_ent="no"
      log_is_ent=""
   create_bintar="no"
create_p8_bintar="no"
      create_win="no"
   create_debian="no"
   create_ubuntu="no"
      create_yum="no"
           fixed="no"
     incl_galera="no"
      is_cluster="no"
  log_is_cluster=""
             log="no"
          skipit="no"
         log_log=""
   galera_suffix=""
 exclude_release=""
        treeflag=false
         revflag=false
         numflag=false
         tarflag=false

#-------------------------------------------------------------------------------
# Functions
#-------------------------------------------------------------------------------

runCommand() {
  echo "+ ${@}"
  sleep 1
  if ${@} ; then
    return 0
  else
    return 1
  fi
}

userResponse() {
  question="${@}"
  read -p "${question} " -n 1
  echo
  ANSWER=${REPLY}
  RESPONSE=${REPLY}
  return 0
}

userInput() {
  question="$@"
  echo
  read -p "${question} "
  echo
  INPUT=${REPLY}
  return 0
}

secureUserInput() {
  question="${@}"
  SECUREINPUT="false"
  REPLY="alsofalse"
  while [ "${SECUREINPUT}" != "${REPLY}" ]; do
    read -s -p "${question} "
    echo
    SECUREINPUT="${REPLY}"
    read -s -p "Please enter it again: "
    echo
    if [ "${SECUREINPUT}" != "${REPLY}" ]; then
      echo
      echo "The two entries do not match."
      echo
    else
      echo
      echo "The two entries match. Continuing."
      echo
      return 0
    fi
  done
}

skip_it() {
  skipit="yes"
}

prepare_bintar_and_source_packages() {
  create_bintar="yes"
}

prepare_Windows_packages() {
  create_win="yes"
}

prepare_Debian_packages() {
  create_debian="yes"
}

prepare_Ubuntu_packages() {
  create_ubuntu="yes"
}

prepare_yum_packages() {
  create_yum="yes"
}

include_Galera_packages_in_repositories() {
  incl_galera="yes"
}

create_a_template_file() {
cat >> ${dir_conf}/prep.conf <<END
#-------------------------------------------------------------------------------
# default conf file for the MariaDB 'prep' script
#-------------------------------------------------------------------------------
# The 'prep' script is part of mariadb.org-tools on GitHub
#   git clone https://github.com/MariaDB/mariadb.org-tools.git

# Please edit and put in valid paths

# Full path to where buildbot saves files
dir_archive="/path/to/archive/pack"

# Full path to where various packages are located
dir_galera="/path/to/galera"
dir_jemalloc="/path/to/jemalloc" # Location of jemalloc pkgs
dir_nmap="/path/to/nmap" # nmap pkg for sles12
dir_at="/path/to/advance-toolchain" # Location of at pkgs
dir_rpm_shared="/path/to/shared/rpm/dir"
dir_judy="/path/to/judy" # Location of judy pkgs
dir_libzstd="/path/to/libzstd" # Location of libzstd pkgs
dir_docker="/path/to/docker/repo" # Location of docker repo

dir_maxscale="/path/to/maxscale" # Location of maxscale pkgs

dir_bundles="/path/to/bundles/TX" # where bundle tarballs should be saved

ver_galera="25.3.25"                        # galera version[s] in our repos
ver_galera_preferred="25.3.25"              # preferred galera version
ver_galera4="26.4.0"                        # galera4 version[s] in our repos
ver_galera4_preferred="26.4.0"              # preferred galera4 version
ver_nmap="6.25"                             # current nmap ver in sles12 repo
  
# Full paths to the mkrepo-* scripts
DEBIAN="/path/to/mariadb.org-tools/release/mkrepo-debian.sh"
UBUNTU="/path/to/mariadb.org-tools/release/mkrepo-ubuntu.sh"
   YUM="/path/to/mariadb.org-tools/release/mkrepo-yum.sh"
   CPT="/path/to/mariadb.org-tools/release/create_package_tarballs"
 BNDLS="/path/to/mariadb.org-tools/release/prep-bundles"

# Full path to the galera-* scripts
GALERA_NEW="/path/to/mariadb.org-tools/release/galera-new"

# URL where Windows Builds are located
winbuilder="http://example.net/builds"

# Default gpg options, including the key to use
     gpg_key="0xcbcb082a1bb943db"
    gpg_opts="--quiet -u 0xcbcb082a1bb943db --detach-sign --armor"

 gpg_key_2016="0xF1656F24C74CD1D8" # 2016-03-30 mariadb.org signing key
gpg_opts_2016="--quiet -u 0xF1656F24C74CD1D8 --detach-sign --armor"

 ent_gpg_key="0xce1a3dd5e3c94f49"
ent_gpg_opts="--quiet -u 0xce1a3dd5e3c94f49 --detach-sign --armor"

# Full paths to where the script should store releases
    dir_release="/path/to/mariadb/releases"
       dir_corp="/path/to/corp/releases"
      dir_tools="/path/to/tools/releases"
dir_release_ent="/path/to/mariadb-enterprise/releases"

# Full path to P8 builds (if needed)
dir_archive_p8="/path/to/p8/archive/builds"

# ssh key to use for uploading
ssh_upload_key='.ssh/KEY_NAME'

# Mirrors
staging_mirror="mirror_name"
primary_mirror="mirror_name"
primary_mirror_rsync="rsync_addr_of_primary_mirror"
corp_mirror="mirror_name"
corp_mirror_path="/dest/dir/on/corp/mirror"
corp_bundles_path="/home/mariadb-repos/bundles/TX"
corp_tools_path="/home/mariadb-repos/mariadb-enterprise-tools"
yum_primary_mirror="bb01"
yum_mirrors="mirror names"
yum_mirror_path="/dest/dir/on/yum/mirror"

# Connectors
cj_home="/path/to/connector/java/home"
cj_home_corp="remote_home"
cc_home="/path/to/connector/c/home"
cc_home_corp="remote_home"
co_home="/path/to/connector/odbc/home"
co_home_corp="remote_home"

# vim: filetype=sh

END
chown ${USER}: ${dir_conf}/prep.conf
}

logSettings() {
cat >> ${dir_log}/prep.log <<END

# Prepped $(date)
# Command:
#   $0 -${log_displayusage}${log_demo}${log_run_script}${log_log}${log_is_ent}${log_is_cluster} -t ${tree} -r ${rev} -v ${num} -b ${tarbuildnum} 
# tree="${tree}"
# rev="${rev}"
# num="${num}"
# tarbuildnum="${tarbuildnum}"
# version="${version}"
# dir_release/dir_name="${dir_release}/${dir_name}"
# is_ent="${is_ent}"
# is_cluster="${is_cluster}"
# create_bintar="${create_bintar}"
# create_win="${create_win}"
# create_debian="${create_debian}"
# create_ubuntu="${create_ubuntu}"
# create_yum="${create_yum}"
# incl_galera="${incl_galera}"
# dir_archive="${dir_archive}"
# dir_galera="${dir_galera}"
# DEBIAN="${DEBIAN}"
# UBUNTU="${UBUNTU}"
# YUM="${YUM}"
# winbuilder="${winbuilder}"
# dir_archive_p8="${dir_archive_p8}"
# gpg_opts="${gpg_opts}"

END
chown ${USER}: ${dir_conf}/prep.conf
}

pressAnyKeyToContinue() {
  echo
  read -p "Press any key to continue." -n 1
  echo
  return 0
}

readyToSign() {
  local cont
  cont=""
}

shouldI() {
  local cont
  cont=""
   while [ -z ${cont} ]; do
     userResponse "Should I ${@//_/ }? [y/n]"
     case ${ANSWER} in
      "y")
        ${@}
        cont="yes"
        ANSWER=""
        return 0
        ;;
      "n")
        echo "Skipping . . . "
        cont="yes"
        ANSWER=""
        return 0
        ;;
      *)
        echo "Please answer [y]es or [n]o."
        echo
        cont=""
        ;;
    esac
  done
}



loadDefaults() {
  # Load the paths (if they exist)
  if [ -f ${dir_conf}/prep.conf ]; then
      . ${dir_conf}/prep.conf
  else
    echo
    echo "The file ${dir_conf}/prep.conf does not exist in your home"
    echo "directory. If it does not exist, and have valid settings in it,"
    echo "this script will fail. I can create a default template file for you"
    echo "to fill out. Afterwards, please re-run this script."
    echo
    shouldI create_a_template_file
    # after creating the file, check if it exists again, if not, exit
    if [ ! -f ${dir_conf}/prep.conf ]; then
      echo "I was unable to create ${dir_conf}/prep.conf"
      echo "Exiting..."
      exit 3
    else
      echo
      echo "Template file created at ${dir_conf}/prep.conf"
      echo "Please edit and re-run this script."
      echo
      exit 0
    fi
  fi
}

usage() {
  set +x
  echo
  echo
  echo "usage: $0 -y[deghl] -t <tree> -r <revision> -v <version> -b <tarbuildnum>"
  echo "  -y : actually run the script"
  echo "  -d : run the script in demo mode"
  echo "  -e : this is a MariaDB Enterprise release"
  echo "  -g : this is a MariaDB Galera Cluster or Enterprise Cluster release"
  echo "  -h : display this usage message"
  echo "  -l : log the <tree>, <revision>, <tarbuildnum>, & etc... to ${dir_log}/prep.log"
  echo "  -t <tree> : the MariaDB source code tree"
  echo "  -r <revision> : the MariaDB source code tree revision"
  echo "  -v <version> : the MariaDB version number"
  echo "  -b <tarbuildnum> : the Buildbot tarbuildnum"
  echo
  echo
  set -x
}

line() {
  echo "-------------------------------------------------------------------------------"
}

message() {
  message="${@}"
  echo;echo;echo;
  echo;line;echo "${message}";line;
}

rsync_wrapper() {
  local upload
  upload=""
  rsync_body="${@}"
  message "Doing a dry run..."
  set -x
  rsync --dry-run ${rsync_body}
  set +x
  echo;echo;echo;
  while [ -z ${upload} ]; do
    userResponse "Does the above look OK? [y/n]"
    case ${ANSWER} in
      "y")
        message "Uploading for real..."
        set -x
        rsync ${rsync_body}
        set +x
        echo;echo;echo
        upload="yes"
        ANSWER=""
        return 0
        ;;
      "n")
        echo "+ Something went wrong..."
        ANSWER=""
        exit 1
        ;;
      *)
        echo "Please answer [y]es or [n]o."
        echo
        upload=""
        ;;
    esac
  done
}

rsync_wrapper_staging() {
  local upload_staging
  upload_staging=""
  rsync_body_staging="${@}"
  message "Doing a dry run..."
  set -x
  ssh -t -t ${staging_mirror} "rsync --dry-run ${rsync_body_staging}"
  set +x
  echo;echo;echo;
  while [ -z ${upload_staging} ]; do
    userResponse "Does the above look OK? [y/n]"
    case ${ANSWER} in
      "y")
        message "Uploading for real..."
        set -x
        ssh -t -t ${staging_mirror} "rsync ${rsync_body_staging}"
        set +x
        echo;echo;echo
        upload_staging="yes"
        ANSWER=""
        return 0
        ;;
      "n")
        echo "+ Something went wrong..."
        ANSWER=""
        exit 1
        ;;
      *)
        echo "Please answer [y]es or [n]o."
        echo
        upload_staging=""
        ;;
    esac
  done
}

rsync_wrapper_primary() {
  local upload_primary
  upload_primary=""
  rsync_body_primary="${@}"
  message "Doing a dry run..."
  set -x
  ssh -t -t ${primary_mirror} "rsync --dry-run ${rsync_body_primary}"
  set +x
  echo;echo;echo;
  while [ -z ${upload_primary} ]; do
    userResponse "Does the above look OK? [y/n]"
    case ${ANSWER} in
      "y")
        message "Uploading for real..."
        set -x
        ssh -t -t ${primary_mirror} "rsync ${rsync_body_primary}"
        set +x
        echo;echo;echo
        upload_primary="yes"
        ANSWER=""
        return 0
        ;;
      "n")
        echo "+ Something went wrong..."
        ANSWER=""
        exit 1
        ;;
      *)
        echo "Please answer [y]es or [n]o."
        echo
        upload_primary=""
        ;;
    esac
  done
}

#===  FUNCTION  ================================================================
#          NAME:  upload_the_bundles_to_the_staging_mirror
#   DESCRIPTION:  Transfer bundles to the staging mirror
#===============================================================================
upload_the_bundles_to_the_staging_mirror() {
  rsync_wrapper "-av --delete-after ${dir_bundles}/mariadb*${num}* ${staging_mirror}:${dir_bundles}/"
}

#===  FUNCTION  ================================================================
#          NAME:  upload_bundles_from_the_staging_mirror_to_the_corp_mirror
#   DESCRIPTION:  Sync the release from the primary public mirror to the corp
#                 mirror
#===============================================================================
upload_bundles_from_the_staging_mirror_to_the_corp_mirror() {
  rsync_wrapper_staging "-av --delete-after ${dir_bundles}/mariadb*${num}* ${corp_mirror}:${corp_bundles_path}/"
}

#===  FUNCTION  ================================================================
#          NAME:  upload_to_the_staging_mirror
#   DESCRIPTION:  Transfer the release to the staging mirror
#===============================================================================
upload_to_the_staging_mirror() {
  if [ "${galera_suffix}" = "-galera" ]; then
    rsync_wrapper "-av --delete-after --exclude=exclude --exclude=*.orig ${dir_release}/${version_nog} ${dir_release}/${dir_name} ${staging_mirror}:${dir_release}/"
  else
    rsync_wrapper "-av --delete-after --exclude=exclude --exclude=*.orig ${dir_release}/${dir_name} ${staging_mirror}:${dir_release}/"
  fi
}

#===  FUNCTION  ================================================================
#          NAME:  copy_release_dir_to_corp_dir_so_corp_upload_is_smaller
#   DESCRIPTION:  corp and org release dirs are similar, so copying from one to
#                 the other before doing the corp upload saves bandwidth
#===============================================================================
copy_release_dir_to_corp_dir_so_corp_upload_is_smaller() {
  if [ "${galera_suffix}" = "-galera" ]; then
    rsync_wrapper_staging "-av --delete-after --exclude=exclude --exclude=*.orig ${dir_release}/${version_nog} ${dir_release}/${dir_name} ${dir_corp}/"
  else
    rsync_wrapper_staging "-av --delete-after --exclude=exclude --exclude=*.orig ${dir_release}/${dir_name} ${dir_corp}/"
  fi
}

#===  FUNCTION  ================================================================
#          NAME:  upload_corp_dir_to_the_staging_mirror
#   DESCRIPTION:  Transfer the corp release to the staging mirror
#===============================================================================
upload_corp_dir_to_the_staging_mirror() {
  if [ "${galera_suffix}" = "-galera" ]; then
    rsync_wrapper "-av --delete-after --exclude=exclude --exclude=*.orig ${dir_corp}/${version_nog} ${dir_corp}/${dir_name} ${staging_mirror}:${dir_corp}/"
  else
    rsync_wrapper "-av --delete-after --exclude=exclude --exclude=*.orig ${dir_corp}/${dir_name} ${staging_mirror}:${dir_corp}/"
  fi
}


#===  FUNCTION  ================================================================
#          NAME:  upload_from_the_staging_mirror_to_the_primary_mirror
#   DESCRIPTION:  Transfer the release from the staging mirror to the primary
#                 mirror
#===============================================================================
upload_from_the_staging_mirror_to_the_primary_mirror() {
  if [ "${galera_suffix}" = "-galera" ]; then
    rsync_wrapper_staging "-av --delete-after --exclude=exclude --exclude=*.orig ${dir_release}/${version_nog} ${dir_release}/${dir_name} ${primary_mirror}:data/"
  else
    rsync_wrapper_staging "-av --delete-after --exclude=exclude --exclude=*.orig ${dir_release}/${dir_name} ${primary_mirror}:data/"
  fi
}

#===  FUNCTION  ================================================================
#          NAME:  upload_from_the_staging_mirror_to_the_yum_mirrors
#   DESCRIPTION:  Transfer files from the primary mirror to the yum repository
#                 mirrors
#===============================================================================
upload_from_the_staging_mirror_to_the_yum_mirrors() {
  # After the staging mirror has the files, rsync to the bb boxes:
  #ssh -t -t ${yum_primary_mirror} "mkdir -v ${yum_mirror_path}/${num} ; rsync -av --delete-after --delay-updates ${primary_mirror_rsync}/${version_nog}/yum/ ${yum_mirror_path}/${num}/"; 

  set -x
  ssh -t -t ${yum_primary_mirror} "if [ ! -d '${yum_mirror_path}/${num}' ];then mkdir -v ${yum_mirror_path}/${num};fi" 
  set +x

  if [ "${galera_suffix}" = "-galera" ]; then
    rsync_wrapper_staging "-av --delete-after --exclude=exclude --exclude=*.orig ${dir_release}/${version_nog}/yum/ ${yum_primary_mirror}:${yum_mirror_path}/${num}/"
  else
    rsync_wrapper_staging "-av --delete-after --exclude=exclude --exclude=*.orig ${dir_release}/${dir_name}/yum/ ${yum_primary_mirror}:${yum_mirror_path}/${num}/"
  fi

  set -x
  for yum_mirror in ${yum_mirrors} ;do 
    #echo;echo;echo;line; echo "uploading to ${yum_mirror}";line;
    ssh -t -t ${yum_primary_mirror} "rsync -a --info=progress2 --delete-after --delay-updates ${yum_mirror_path}/${num} ${yum_mirror}:${yum_mirror_path}/"; 
    #ssh -t -t ${yum_mirror} "mkdir -v ${yum_mirror_path}/${num} ; rsync -av --delete-after --delay-updates ${yum_primary_mirror}:data/${version_nog}/yum/ ${yum_mirror_path}/${num}/"; 
  done
  set +x
}

#===  FUNCTION  ================================================================
#          NAME:  activate_the_yum_repos
#   DESCRIPTION:  Run the commands necessary to make the repository files public
#===============================================================================
activate_the_yum_repos() {
  if [ "${galera_suffix}" = "-galera" ]; then
    # Do nothing if this is a galera release
    echo "This is a galera release, skipping this step..."
  else
    echo;echo;
    set -x
    for yum_mirror in ${yum_primary_mirror} ${yum_mirrors} ;do 
      ssh -t -t ${yum_mirror} "cd ${yum_mirror_path}/;rm -v ${major};ln -sv ${num} ${major};echo;echo"; 
    done
    set +x
  fi
  rsync_wrapper_primary "--delete-after -av data/${version_nog}/yum/ data/yum/${major}/";
  set -x
  ssh -t -t ${primary_mirror} "./trigger-mariadb";
  set +x
}

#===  FUNCTION  ================================================================
#          NAME:  activate_the_deb_repos
#   DESCRIPTION:  Run the commands necessary to make the repository files public
#===============================================================================
activate_the_deb_repos() {
  set -x
  set +x
  rsync_wrapper_primary "--delete-after -av data/${version_nog}/repo/ data/repo/${major}/";
  set -x
  ssh -t -t ${primary_mirror} "./trigger-mariadb";
  set +x
}

#===  FUNCTION  ================================================================
#          NAME:  activate_the_corp_repos
#   DESCRIPTION:  Run the commands necessary to make the repository files public
#===============================================================================
activate_the_corp_repos() {
  if [ "${galera_suffix}" = "-galera" ]; then
    # Do nothing if this is a galera release
    echo "This is a galera release, skipping this step..."
  else
    echo;echo;
    set -x
    ssh -t -t ${corp_mirror} "cd ${corp_mirror_path}/;rm -v mariadb-${major};ln -sv ${dir_name} mariadb-${major};echo;echo";
    set +x
  fi
}

create_package_tarballs() {
  set -x
  pushd ${CPT}
  ./create_package_tarballs ${dir_corp}/${version_nog}/
  popd
  set +x
}

create_bundles() {
  message "Creating the ${num} bundles"
  ${BNDLS} ${num}
  message "Done creating the ${num} bundles!"
}

bundles() {
  local bundle
  bundle=""
   while [ -z ${bundle} ]; do
     userResponse "Does this release have bundles? [y/n]"
     case ${ANSWER} in
      "y")
        ${@}
        bundle="yes"
        ANSWER=""

        shouldI create_bundles

        echo;echo;echo;echo

        shouldI upload_the_bundles_to_the_staging_mirror

        echo;echo;echo;echo

        shouldI upload_bundles_from_the_staging_mirror_to_the_corp_mirror

        return 0
        ;;
      "n")
        echo "Skipping . . . "
        bundle="yes"
        ANSWER=""
        return 0
        ;;
      *)
        echo "Please answer [y]es or [n]o."
        echo
        bundle=""
        ;;
    esac
  done
}


#===  FUNCTION  ================================================================
#          NAME:  upload_from_the_staging_mirror_to_the_corp_mirror
#   DESCRIPTION:  Sync the release from the primary public mirror to the corp
#                 mirror
#===============================================================================
upload_from_the_staging_mirror_to_the_corp_mirror() {
  if [ "${galera_suffix}" = "-galera" ]; then
    rsync_wrapper_staging "-av --delete-after --exclude=exclude --exclude=*.orig ${dir_corp}/${version_nog} ${dir_corp}/${dir_name} ${corp_mirror}:${corp_mirror_path}/"
  else
    rsync_wrapper_staging "-av --delete-after --exclude=exclude --exclude=*.orig ${dir_corp}/${dir_name} ${corp_mirror}:${corp_mirror_path}/"
  fi

#  if [ "${galera_suffix}" = "-galera" ]; then
#    ssh -t -t ${corp_mirror} rsync -av --delete-after ${primary_mirror_rsync}/${dir_name} ${primary_mirror_rsync}/${version_nog} ${corp_mirror_path}/
#  else
#    ssh -t -t ${corp_mirror} rsync -av --delete-after ${primary_mirror_rsync}/${version_nog} ${corp_mirror_path}/
#  fi
}

#===  FUNCTION  ================================================================
#          NAME:  maybe_create_release_dir
#   DESCRIPTION:  Create the release dir if it doesn't exist
#===============================================================================
maybe_create_release_dir() {
  if [ ! -d ${dir_release}/${dir_name} ]; then
    echo
    line
    echo "+ creating release dir..."
    line
    mkdir -v ${dir_release}/${dir_name}
    echo
  fi
  if [ ! -d ${dir_corp}/${dir_name} ]; then
    echo
    line
    echo "+ creating corp release dir..."
    line
    mkdir -v ${dir_corp}/${dir_name}
    echo
  fi
}

#===  FUNCTION  ================================================================
#          NAME:  maybe_fix_permissions
#   DESCRIPTION:  Fix permissions on the buildbot dirs, if they haven't been
#                 fixed already during this run of the script
#===============================================================================
maybe_fix_permissions() {
  if [ "${fixed}" = "no" ]; then
    echo
    line
    echo "+ fixing permissions..."
    line

    # Make sure parent dirs are OK first
    sudo chmod -c 755 ${dir_archive}/${tree}/
    sudo chmod -c 755 ${dir_archive}/${tree}/build-${tarbuildnum}/
    sudo chmod -c 755 ${dir_archive_p8}/${tree}/
    sudo chmod -c 755 ${dir_archive_p8}/${tree}/${rev}/

    # scan and adjust perms of subdirs
    for dir in $(sudo find ${dir_archive}/${tree}/build-${tarbuildnum}/ -type d);do
      sudo chmod 755 "${dir}"
    done
    for file in $(sudo find ${dir_archive}/${tree}/build-${tarbuildnum}/ -type f);do
      sudo chmod 644 "${file}"
    done
    for dir in $(sudo find ${dir_archive_p8}/${tree}/${rev}/ -type d);do
      sudo chmod 755 "${dir}"
    done
    for file in $(sudo find ${dir_archive_p8}/${tree}/${rev}/ -type f);do
      sudo chmod 644 "${file}"
    done
    fixed="yes" # set fixed to 'yes' so that this function doesn't run again
    echo "+ done fixing permissions"
    echo
    echo
  fi
}


#===  FUNCTION  ================================================================
#          NAME:  display_the_previous_yum_directory
#   DESCRIPTION:  A simple function to list (using tree) the contents of the
#                 previous release's yum directory. Useful for seeing what
#                 releases are in it.
#===============================================================================
display_the_previous_yum_directory() {
  echo; line;
  echo "Here is the previous yum directory:"
  line; echo
  tree ${dir_release}/mariadb-${prev_release}/yum
  echo;echo;echo;
  pressAnyKeyToContinue
}

#===  FUNCTION  ================================================================
#          NAME:  exclude_an_old_release_from_the_yum_dir
#   DESCRIPTION:  This function sets the exclude_release variable. If this
#                 variable is set to something non-zero then the rsync that
#                 handles the yum repo will exclude it.
#===============================================================================
exclude_an_old_release_from_the_yum_dir() {
  userInput "What release should I exclude? (e.g. 10.2.13)"
  exclude_release="${INPUT}"
}

#===  FUNCTION  ================================================================
#          NAME:  update_the_docker_mariadb_version
#   DESCRIPTION:  This function updates the version file for 10.1+
#                 Docker scripts
#===============================================================================
update_the_docker_mariadb_version() {
  if [ ! -d ${dir_docker} ]; then
    set -x
    git clone git@github.com:mariadb-corporation/mariadb-server-docker ${dir_docker}
    set +x
  fi
  pushd ${dir_docker}
    git checkout ${major}
    git pull
    if test -d ${major}; then       # only update version if the dir exists
      set -x
      echo ${num} > ${major}/version
      vi ${major}/version
      git add ${major}/version
      git commit -m "MariaDB Server $num" ${major}/version
      git push
      set +x
    fi
  popd
}


#===  FUNCTION  ================================================================
#          NAME:  generate_the_file_list_pickle_for_org_downloads
#   DESCRIPTION:  This function logs in to the primary mirror and runs the
#                 command to generate the pickle that is then imported into the
#                 mariadb.org downloads system.
#===============================================================================
generate_the_file_list_pickle_for_org_downloads() {
  ssh -t -t ${primary_mirror} "python generate_file_list.py data/ --release=${dir_name}";
}

#-------------------------------------------------------------------------------
# Main Script
#-------------------------------------------------------------------------------

# The first thing we need to do is parse the options
while getopts 'b:deghlr:t:v:y' OPTION
do
  case $OPTION in
    d)  # Not implemented yet
      demo="yes"
      log_demo="d"
      ;;
    e)  # This is a MariaDB Enterprise or MariaDB Enterprise Cluster release
      is_ent="yes"
      log_is_ent="e"
      ;;
    g)  # This is a MariaDB Galera Cluster or Enterprise Cluster release
        # -e & -g both need to be set for a MariaDB Enterprise Cluster release
      galera_suffix="-galera"
      is_cluster="yes"
      log_is_cluster="g"
      ;;
    h)  # Display a helpful usage message
      displayusage="yes"
      log_displayusage="h"
      ;;
    l)  # Log the release to ${dir_log}/prep.log
      log="yes"
      log_log="l"
      ;;
    r)  # The release revision
      rev="${OPTARG}"
      revflag=true
      ;;
    t)  # The release tree
      tree="${OPTARG}"
      treeflag=true
      ;;
    v)  # The version number of this release
      num="${OPTARG}"
      numflag=true
      ;;
    b)  # The tarbuildnum of the release
      tarbuildnum="${OPTARG}"
      tarflag=true
      ;;
    y)  # Actually run this script (helps prevent accidental runs)
      run_script="yes"
      log_run_script="y"
      ;;
    \?) # Display a helpful usage message
      displayusage="yes"
      ;;
    :)  # Error when an option is used that requires an argument
      displayusage="yes"
      echo "Option -$OPTARG requires an argument."
      ;;
  esac
done

shift $(($OPTIND - 1))

if ! ${revflag} || ! ${numflag} || ! ${treeflag} || ! ${tarflag} ; then
  #if [[ -d $1 ]]; then
    echo
    line
    echo "-r -t -v and -b, along with their appropriate arguments, are mandatory" >&2
    line
    usage
    exit 4
  #fi
fi

# make sure we are running as root
#if (( `id -u` != 0 )); then { echo "Sorry, ${0} must be run using sudo. Exiting..."; exit; } fi

# Display usage message and quit if necessary
if [ "${displayusage}" = "yes" ] || [ "${run_script}" != "yes" ]; then
  usage
  exit 0
fi

loadDefaults                                    # Load Default paths and vars

# create major variable that has the base major version of mariadb (e.g. 10.3)
major=${num%.*}

# Set the real version of galera to use
if [ ${major} = "10.4" ]; then
  ver_galera_real=${ver_galera4}
  ver_galera_preferred_real=${ver_galera4_preferred}
else
  ver_galera_real=${ver_galera}
  ver_galera_preferred_real=${ver_galera_preferred}
fi

# Put ${galera_suffix} and ${num} together to form the base version string
if [ "${is_ent}" = "yes" ];then
  if [ "${galera_suffix}" = "-galera" ]; then
    version="mariadb-enterprise-cluster-${num}"
  else
    version="mariadb-enterprise-${num}"
  fi
else
  version="mariadb${galera_suffix}-${num}"
  version_nog="mariadb-${num}"
fi

shouldI prepare_bintar_and_source_packages
if [ "${galera_suffix}" != "-galera" ]; then
  shouldI prepare_Windows_packages
fi

case $tree in
  *5.5* )
    echo "+ no Debian for 5.5"
    ;;
  *)
    shouldI prepare_Debian_packages
    ;;
esac

shouldI prepare_Ubuntu_packages
shouldI prepare_yum_packages
#shouldI include_Galera_packages_in_repositories
include_Galera_packages_in_repositories

# Set various options that change depending on whether this is an enterprise
# release or not
if [ "${is_ent}" = "yes" ];then
  suffix="signed-ent"

  # new enterprise key (2014-12-18)
  gpg_opts="--quiet -u 0xce1a3dd5e3c94f49 --detach-sign --armor"

  dir_release="${dir_release_ent}"  # Default location for MariaDB Enterprise
  build_dirs="${ent_build_dirs_x86_64}" # Default dirs for MariaDB Enterprise

  if [ "${galera_suffix}" = "-galera" ]; then
    dir_name="${num}-cluster" # release directory name for Enterprise Cluster
  else
    dir_name="${num}"         # release directory name for MariaDB Enterprise
  fi
else
  suffix="signed"
  build_dirs="${build_dirs_x86} ${build_dirs_x86_64}" # Default dirs for MariaDB
  if [ "${tree}" = "10.0-FusionIO" ]; then
    dir_name="${version}-FusionIO" # FusionIO releases get a custom directory
  else
    dir_name="${version}" # normal releases use ${version} as ${dir_name}
  fi
  gpg_opts="--quiet -u 0xcbcb082a1bb943db --detach-sign --armor" 
  #gpg_opts="--quiet -u 0xF1656F24C74CD1D8 --detach-sign --armor" # new GPG key for Sid
fi

if [ ${log} = "yes" ]; then
  logSettings
fi

#exit 0;


echo
echo
line
echo "+ creating the ${version} release"
line

# start the ssh-agent and add the upload key
eval $(ssh-agent)
ssh-add ${ssh_upload_key}

# start the gpg-agent if it's not already started
eval $(gpg-agent --daemon)




#-------------------------------------------------------------------------------
#  Binary Tarballs and Source
#-------------------------------------------------------------------------------
if [ "${create_bintar}" != "no" ]; then
  maybe_create_release_dir      # Create release dirs if they don't exist
  maybe_fix_permissions         # fix permissions if needed
  pushd ${dir_release}/${dir_name}
  line
  echo "+ transfering bintar & source packages..."
  line
  for dir_pair in ${build_dirs}; do
    dir_array=(${dir_pair//:/ })
    if [ -d ${dir_release}/${dir_name}/${dir_array[1]} ]; then
      echo "${dir_array[1]} already exists under ${dir_release}/${dir_name}/"
      shouldI skip_it
    fi
    if [ "${skipit}" = "yes" ]; then
      echo "${dir_array[1]} has been skipped"
      skipit="no"
      echo
    else
      # Not skipping
      if [ ! -d /run/shm/${dir_array[1]} ]; then
        mkdir -v /run/shm/${dir_array[1]}
      fi
      case ${dir_array[1]} in
        'macOS')
          location="${dir_archive_p8}/${tree}/${rev}/${dir_array[0]}"
          ;;
        *)
          location="${dir_archive}/${tree}/build-${tarbuildnum}/${dir_array[0]}"
          ;;
      esac
      if [ "${dir_array[1]}" = "source" ]; then
        if runCommand rsync ${rsync_opts} "${location}/mariadb-${num}.tar.gz" "/run/shm/${dir_array[1]}/mariadb${galera_suffix}-${num}.tar.gz"; then
          pushd /run/shm/${dir_array[1]}
          # rename the source tarball for enterprise
          if [ "${is_ent}" = "yes" ];then
            mv -vi mariadb${galera_suffix}-${num}.tar.gz mariadb-enterprise${galera_suffix}-${num}.tar.gz
          fi
          echo "+ updating source tarball md5sum..."
          if [ -e md5sums.txt ]; then
            rm -v md5sums.txt
          fi
          md5sum ./mariadb* >> md5sums.txt

          echo "+ updating source tarball sha1sum..."
          if [ -e sha1sums.txt ]; then
            rm -v sha1sums.txt
          fi
          sha1sum ./mariadb* >> sha1sums.txt

          echo "+ updating source tarball sha256sum..."
          if [ -e sha256sums.txt ]; then
            rm -v sha256sums.txt
          fi
          sha256sum ./mariadb* >> sha256sums.txt

          echo "+ updating source tarball sha512sum..."
          if [ -e sha512sums.txt ]; then
            rm -v sha512sums.txt
          fi
          sha512sum ./mariadb* >> sha512sums.txt

          echo "+ signing source tarball and sum files..."
          # remove any signature files before signing, if they exist
          for sig_file in $(ls ./*.asc); do
            rm "${sig_file}"
          done
          # sign the MariaDB source tarball
          gpg2 ${gpg_opts} mariadb*${galera_suffix}-${num}.tar.gz
          # sign the sum files as well
          gpg2 ${gpg_opts} md5sums.txt
          gpg2 ${gpg_opts} sha1sums.txt
          gpg2 ${gpg_opts} sha256sums.txt
          gpg2 ${gpg_opts} sha512sums.txt
          popd
          mv -vi /run/shm/${dir_array[1]} ${dir_release}/${dir_name}/
          echo "+ copying ${dir_array[1]} to ${dir_corp}/${dir_name}/"
          rsync -avP --delete ${dir_release}/${dir_name}/${dir_array[1]} ${dir_corp}/${dir_name}/
        fi
        echo "+ transfer of ${dir_array[1]} done"
        echo
      elif runCommand rsync ${rsync_opts} "${location}/" "/run/shm/${dir_array[1]}/"; then
        echo "+ transfer of ${dir_array[1]} done"
        pushd /run/shm/${dir_array[1]}/
        if [ "${dir_array[1]}" = "bintar-linux-glibc_214-x86_64" ] || [ "${dir_array[1]}" = "bintar-linux-glibc_214-x86" ]; then
          # for the quantal bintars, we need to rename them before signing
          if [ "${dir_array[1]}" = "bintar-linux-glibc_214-x86_64" ]; then
            mv -vi *-linux-x86_64.tar.gz ${version}-linux-glibc_214-x86_64.tar.gz
            galera_arch="x86_64"
          else
            mv -vi *-linux-i686.tar.gz ${version}-linux-glibc_214-i686.tar.gz
            galera_arch="i686"
          fi

          if [ "${galera_suffix}" = "-galera" ] || [[ "${tree}" = *10.[1-9]* ]]; then
            # If this is a galera release we need to copy in the galera libraries
            # and repack the bintar
            runCommand tar -zxf ${version}-linux-glibc_214-${galera_arch}.tar.gz
            mv -vi ${version}-linux-glibc_214-${galera_arch}.tar.gz ${version}-linux-glibc_214-${galera_arch}.tar.gz.orig
            mv -vi *-linux-${galera_arch} ${version}-linux-glibc_214-${galera_arch}
            #cp -avi ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-glibc_214-${galera_arch}/usr/bin/* ${version}-linux-glibc_214-${galera_arch}/bin/
            #cp -avi ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-glibc_214-${galera_arch}/usr/lib/* ${version}-linux-glibc_214-${galera_arch}/lib/
            rsync -av ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-glibc_214-${galera_arch}/usr/bin/ ${version}-linux-glibc_214-${galera_arch}/bin/
            rsync -av ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-glibc_214-${galera_arch}/usr/lib/ ${version}-linux-glibc_214-${galera_arch}/lib/
            runCommand tar -czf ${version}-linux-glibc_214-${galera_arch}.tar.gz ${version}-linux-glibc_214-${galera_arch}
            rm -rf ${version}-linux-glibc_214-${galera_arch}
          else
            echo "not a galera release, but still unpacking, re-packing so the dir name is correct"
            runCommand tar -zxf ${version}-linux-glibc_214-${galera_arch}.tar.gz
            mv -vi ${version}-linux-glibc_214-${galera_arch}.tar.gz ${version}-linux-glibc_214-${galera_arch}.tar.gz.orig
            mv -vi *-linux-${galera_arch} ${version}-linux-glibc_214-${galera_arch}
            runCommand tar -czf ${version}-linux-glibc_214-${galera_arch}.tar.gz ${version}-linux-glibc_214-${galera_arch}
            rm -rf ${version}-linux-glibc_214-${galera_arch}
          fi

          # since we renamed them, we also need to regenerate the sums
          if [ -e md5sums.txt ]; then
            rm -v md5sums.txt
          fi
          md5sum ./${version}-*.tar.gz >> md5sums.txt

          if [ -e sha1sums.txt ]; then
            rm -v sha1sums.txt
          fi
          sha1sum ./${version}-*.tar.gz >> sha1sums.txt

          if [ -e sha256sums.txt ]; then
            rm -v sha256sums.txt
          fi
          sha256sum ./${version}-*.tar.gz >> sha256sums.txt

          if [ -e sha512sums.txt ]; then
            rm -v sha512sums.txt
          fi
          sha512sum ./${version}-*.tar.gz >> sha512sums.txt

        elif [ "${dir_array[1]}" = "bintar-linux-systemd-x86_64" ] || [ "${dir_array[1]}" = "bintar-linux-systemd-x86" ]; then
          # for the systemd bintars, we need to rename them before signing
          if [ "${dir_array[1]}" = "bintar-linux-systemd-x86_64" ]; then
            mv -vi *-linux-x86_64.tar.gz ${version}-linux-systemd-x86_64.tar.gz
            galera_arch="x86_64"
          else
            mv -vi *-linux-i686.tar.gz ${version}-linux-systemd-i686.tar.gz
            galera_arch="i686"
          fi

          if [ "${galera_suffix}" = "-galera" ] || [[ "${tree}" = *10.[1-9]* ]]; then
            # If this is a galera release we need to copy in the galera libraries
            # and repack the bintar
            runCommand tar -zxf ${version}-linux-systemd-${galera_arch}.tar.gz
            mv -vi ${version}-linux-systemd-${galera_arch}.tar.gz ${version}-linux-systemd-${galera_arch}.tar.gz.orig
            mv -vi *-linux-${galera_arch} ${version}-linux-systemd-${galera_arch}
            #cp -avi ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-systemd-${galera_arch}/usr/bin/* ${version}-linux-systemd-${galera_arch}/bin/
            #cp -avi ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-systemd-${galera_arch}/usr/lib/* ${version}-linux-systemd-${galera_arch}/lib/
            rsync -av ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-systemd-${galera_arch}/usr/bin/ ${version}-linux-systemd-${galera_arch}/bin/
            rsync -av ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-systemd-${galera_arch}/usr/lib/ ${version}-linux-systemd-${galera_arch}/lib/
            runCommand tar -czf ${version}-linux-systemd-${galera_arch}.tar.gz ${version}-linux-systemd-${galera_arch}
            rm -rf ${version}-linux-systemd-${galera_arch}
          else
            echo "not a galera release, but still unpacking, re-packing so the dir name is correct"
            runCommand tar -zxf ${version}-linux-systemd-${galera_arch}.tar.gz
            mv -vi ${version}-linux-systemd-${galera_arch}.tar.gz ${version}-linux-systemd-${galera_arch}.tar.gz.orig
            mv -vi *-linux-${galera_arch} ${version}-linux-systemd-${galera_arch}
            runCommand tar -czf ${version}-linux-systemd-${galera_arch}.tar.gz ${version}-linux-systemd-${galera_arch}
            rm -rf ${version}-linux-systemd-${galera_arch}
          fi

          # since we renamed them, we also need to regenerate the sums
          if [ -e md5sums.txt ]; then
            rm -v md5sums.txt
          fi
          md5sum ./${version}-*.tar.gz >> md5sums.txt

          if [ -e sha1sums.txt ]; then
            rm -v sha1sums.txt
          fi
          sha1sum ./${version}-*.tar.gz >> sha1sums.txt

          if [ -e sha256sums.txt ]; then
            rm -v sha256sums.txt
          fi
          sha256sum ./${version}-*.tar.gz >> sha256sums.txt

          if [ -e sha512sums.txt ]; then
            rm -v sha512sums.txt
          fi
          sha512sum ./${version}-*.tar.gz >> sha512sums.txt

        elif [ "${dir_array[1]}" = "bintar-linux-x86_64" ] || [ "${dir_array[1]}" = "bintar-linux-x86" ]; then
          if [ "${galera_suffix}" = "-galera" ] || [[ "${tree}" = *10.[1-9]* ]]; then
            # If this is a galera release we need to copy in the galera libraries
            # and repack the bintar, but first we need to set ${galera_arch} to the
            # correct value
            if [ "${dir_array[1]}" = "bintar-linux-x86_64" ]; then
              if [ "${is_ent}" = "yes" ];then
                mv -vi *-linux-x86_64.tar.gz ${version}-linux-x86_64.tar.gz
              fi
              galera_arch="x86_64"
            else
              if [ "${is_ent}" = "yes" ];then
                mv -vi *-linux-i686.tar.gz ${version}-linux-i686.tar.gz
              fi
              galera_arch="i686"
            fi
            runCommand tar -zxf ${version}-linux-${galera_arch}.tar.gz
            mv -vi ${version}-linux-${galera_arch}.tar.gz ${version}-linux-${galera_arch}.tar.gz.orig
            # if the directory isn't named like we want, rename it
            if [ ! -d ${version}-linux-${galera_arch} ]; then
              mv -vi *-linux-${galera_arch} ${version}-linux-${galera_arch}
            fi
            #cp -avi ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-${galera_arch}/usr/bin/* ${version}-linux-${galera_arch}/bin/
            #cp -avi ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-${galera_arch}/usr/lib*/* ${version}-linux-${galera_arch}/lib/
            rsync -av ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-${galera_arch}/usr/bin/ ${version}-linux-${galera_arch}/bin/
            rsync -av ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-${galera_arch}/usr/lib/ ${version}-linux-${galera_arch}/lib/
            #if [ -d ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-${galera_arch}/usr/lib64 ];then
            #  rsync -av ${dir_galera}/galera-${ver_galera_preferred_real}/bintar/galera-${ver_galera_preferred_real}-${galera_arch}/usr/lib64 ${version}-linux-${galera_arch}/
            #fi
            runCommand tar -czf ${version}-linux-${galera_arch}.tar.gz ${version}-linux-${galera_arch}
            rm -rf ${version}-linux-${galera_arch}
            # since we repacked them, we also need to regenerate the sums
            if [ -e md5sums.txt ]; then
              rm -v md5sums.txt
            fi
            md5sum ./${version}-*.tar.gz >> md5sums.txt

            if [ -e sha1sums.txt ]; then
              rm -v sha1sums.txt
            fi
            sha1sum ./${version}-*.tar.gz >> sha1sums.txt

            if [ -e sha256sums.txt ]; then
              rm -v sha256sums.txt
            fi
            sha256sum ./${version}-*.tar.gz >> sha256sums.txt

            if [ -e sha512sums.txt ]; then
              rm -v sha512sums.txt
            fi
            sha512sum ./${version}-*.tar.gz >> sha512sums.txt

          else
            echo "not repacking as this is not a galera release"
          fi
        fi

        echo "+ generating sums in ${dir_array[1]} if they don't exist..."
        if [ -e md5sums.txt ]; then
          echo "...md5sums.txt exists"
        else
          echo "...generating md5sums.txt"
          md5sum ./${version}-* >> md5sums.txt
        fi

        if [ -e sha1sums.txt ]; then
          echo "...sha1sums.txt exists"
        else
          echo "...generating sha1sums.txt"
          sha1sum ./${version}-* >> sha1sums.txt
        fi

        if [ -e sha256sums.txt ]; then
          echo "...sha256sums.txt exists"
        else
          echo "...generating sha256sums.txt"
          sha256sum ./${version}-* >> sha256sums.txt
        fi

        if [ -e sha512sums.txt ]; then
          echo "...sha512sums.txt exists"
        else
          echo "...generating sha512sums.txt"
          sha512sum ./${version}-* >> sha512sums.txt
        fi

        echo "+ finished generating sums in ${dir_array[1]}"

        echo "+ signing files in ${dir_array[1]}..."
        # remove any signature files before signing, if they exist
        for sig_file in $(ls ./*.asc); do
          rm -v "${sig_file}"
        done
        # now that old signatures are gone, sign all files that remain
        for dir_file in $(find . -type f | grep -v orig); do
          gpg2 ${gpg_opts} ${dir_file}
        done
        popd
        mv -vi /run/shm/${dir_array[1]} ${dir_release}/${dir_name}/
        echo "+ finished signing files in ${dir_array[1]}"
        echo
        echo
        # copy the dir to the corp dir
        echo "+ copying ${dir_array[1]} to ${dir_corp}/${dir_name}/"
        runCommand rsync -avP --delete ${dir_release}/${dir_name}/${dir_array[1]} ${dir_corp}/${dir_name}/
        echo
        echo
      else
        echo "! failed to transfer ${dir_array[1]}"
        # if the transfer failed, the directory might be empty, if it is we want it
        # removed, so we run rmdir on it
        #rmdir ${dir_release}/${dir_name}/${dir_array[1]}
        rmdir -v /run/shm/${dir_array[1]}
        echo
      fi
    fi
  done

  # if we are creating a Galera release we need to copy in the galera source and
  # packages (for those not using the repositories)
  if [ "${galera_suffix}" = "-galera" ] || [[ "${tree}" = *10.[1-9]* ]]; then
    line
    echo "+ transfering Galera source and package files..."
    line
    for galera_version in ${ver_galera_real}; do
      mkdir -vp ./galera-${galera_version}
      # rsync the galera dir to the release dir
      if runCommand rsync ${rsync_opts} --exclude=repo "${dir_galera}/galera-${galera_version}-${suffix}/" "./galera-${galera_version}/"; then
        # rsync the galera dir to the corp dir
        if runCommand rsync ${rsync_opts} --exclude=repo --exclude=*ppc64* --exclude=deb/ --exclude=rpm/ "${dir_galera}/galera-${galera_version}-${suffix}/" "${dir_corp}/${dir_name}/galera-${galera_version}/"; then
          echo "+ transfer of ${dir_galera}/galera-${galera_version} done"
        fi
        echo
      else
        echo "! failed to transfer ${dir_galera}/galera-${galera_version}"
        # if the transfer failed, the directory might be empty, if it is we want it
        # removed, so we run rmdir on it
        rmdir "galera-${galera_version}"
        echo
      fi
    done
    echo "+ done transfering Galera source and package files"
    echo
  fi

  echo "+ done transfering bintar & source packages"
  echo
else
  echo
  line
  echo "+ skipping transfering bintar & source packages, as requested..."
  line
  echo
fi



#-------------------------------------------------------------------------------
#  Windows packages
#-------------------------------------------------------------------------------
# We don't need Windows packages for Galera, so don't even try
if [ "${galera_suffix}" != "-galera" ]; then
  if [ "${create_win}" != "no" ]; then
    maybe_create_release_dir
    #maybe_fix_permissions # fix permissions if they haven't already been fixed
    pushd ${dir_release}/${dir_name}
    line
    echo "+ transfering Windows packages..."
    line
    for arch in win32 winx64; do
      if [ ! -d ${dir_release}/${dir_name}/${arch}-packages ]; then
        mkdir ${dir_release}/${dir_name}/${arch}-packages
      fi
      pushd ${dir_release}/${dir_name}/${arch}-packages
      for pkgtype in msi zip; do
        #wget -N ${winbuilder}/${tree}/${rev}/${version}-${arch}.${pkgtype}
        runCommand wget -N ${winbuilder}/${tree}/build-${tarbuildnum}/${arch}-packages/${version}-${arch}.${pkgtype}

        # Download debugsymbols package for 10.2+ releases
        if [ "${pkgtype}" = "zip" ]; then
          case ${tree} in
            '5.5'|'5.5-galera'|'10.0'|'10.0-galera'|'10.1'|'bb-10.1-release'|'bb-10.0-release')
              echo "+ tree=${tree}, so not downloading debugsymbols package..."
              ;;
            *)
              echo "+ tree=${tree}, so downloading debugsymbols package..."
              runCommand wget -N ${winbuilder}/${tree}/build-${tarbuildnum}/${arch}-packages/${version}-${arch}-debugsymbols.${pkgtype}
              ;;
          esac
        fi

      done
      #wget ${winbuilder}/${tree}/${rev}/md5sums.txt
      runCommand wget ${winbuilder}/${tree}/build-${tarbuildnum}/${arch}-packages/md5sums.txt
    done
    line
    echo "+ fixing Win md5sums..."
    line
    for arch in win32 winx64; do
      pushd ${dir_release}/${dir_name}/${arch}-packages
      pwd
      runCommand dos2unix md5sums.txt
      grep ${arch} md5sums.txt > md5sums.txt.tmp
      mv -v md5sums.txt.tmp md5sums.txt
      #pwd
      #cat md5sums.txt
      #echo
      #echo
      #rm -v md5sums.txt
      #md5sum mariadb* >> md5sums.txt
      #cat md5sums.txt
      #echo
      md5sum -c md5sums.txt
      sha1sum ./mariadb* > sha1sums.txt
      sha1sum -c sha1sums.txt
      sha256sum ./mariadb* > sha256sums.txt
      sha256sum -c sha256sums.txt
      sha512sum ./mariadb* > sha512sums.txt
      sha512sum -c sha512sums.txt
      echo
      echo "+ signing ${arch} files"
      # remove any signature files before signing, if they exist
      for sig_file in $(ls ./*.asc); do
        rm "${sig_file}"
      done
      # now that old signatures are gone, sign all files that remain
      for dir_file in $(find . -type f); do
        gpg2 ${gpg_opts} ${dir_file}
      done
      echo "+ finished signing ${arch} files"
      echo
      echo

      # copy the dir to the corp dir
      echo "+ copying ${arch}-packages to ${dir_corp}/${dir_name}/"
      rsync -avP --delete ${dir_release}/${dir_name}/${arch}-packages ${dir_corp}/${dir_name}/
      popd
    done
    popd
    echo "+ done transfering Windows packages"
  else
    line
    echo "+ skipping transfering Windows packages, as requested..."
    line
  fi
fi


#-------------------------------------------------------------------------------
#  Repositories
#-------------------------------------------------------------------------------
if [ "${galera_suffix}" = "-galera" ]; then
  # We don't have separate .deb or .rpm package repos for Galera so if we're
  # doing a Galera release, don't try to create them in the normal way,
  # instead, run the galera-new script to add packages to existing repositories

  line
  echo "+ adding Galera Cluster files to existing repos..."
  line
  echo + ${GALERA_NEW} ${create_debian} ${create_ubuntu} ${create_yum} ${is_ent} ${tree} ${rev} ${num} ${tarbuildnum}
         ${GALERA_NEW} ${create_debian} ${create_ubuntu} ${create_yum} ${is_ent} ${tree} ${rev} ${num} ${tarbuildnum}

else
  maybe_create_release_dir
  pushd ${dir_release}/${dir_name}
  # Since this is not a galera release, create repos normally
  echo
  echo
  echo
  # if the dir doesn't exist, create it
  if [ ! -d ${dir_release}/${dir_name}/repo ]; then
    mkdir ${dir_release}/${dir_name}/repo
  fi

  if [ ! -d ${dir_corp}/${dir_name}/repo ]; then
    mkdir ${dir_corp}/${dir_name}/repo
  fi

  pushd ${dir_release}/${dir_name}/repo

  # create directory for the non-mgc version, if ubuntu or debian packages are
  # going to be created and if it doesn't already exist
  if [ "${create_debian}" != "no" ] || [ "${create_ubuntu}" != "no" ]; then
    if [ ! -d ${dir_release}/repo-no-mgc/${num} ]; then
      mkdir -vp ${dir_release}/repo-no-mgc/${num}
    fi
  fi

  if [ "${create_ubuntu}" != "no" ] || [ "${create_debian}" != "no" ] || [ "${create_yum}" != "no" ]; then
    userInput "What is the previous MariaDB release? (e.g. 10.1.1)"
    prev_release="${INPUT}"
  fi

  #-------------------------------------------------------------------------------
  #  Create Debian Repos
  #-------------------------------------------------------------------------------
  if [ "${create_debian}" != "no" ]; then
    ## if the debian repo dir exists, delete it
    #if [ -d ${dir_release}/${dir_name}/repo/debian ]; then
    #  rm -rf "${dir_release}/${dir_name}/repo/debian"
    #fi

    # trying updating the previous repo instead of creating a new one every time
    echo "+ rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/repo/debian ${dir_release}/${dir_name}/repo/"
            rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/repo/debian ${dir_release}/${dir_name}/repo/
    echo

    line
    echo "+ creating Debian repos..."
    line
    echo "${DEBIAN} ${incl_galera} ${is_ent} ${tree} debian ${dir_archive}/${tree}/build-${tarbuildnum}"
     ${DEBIAN} ${incl_galera} ${is_ent} ${tree} debian ${dir_archive}/${tree}/build-${tarbuildnum}

    # copy the repo to the corp release dir
    echo "+ rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/repo/debian ${dir_corp}/${dir_name}/repo/"
            rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/repo/debian ${dir_corp}/${dir_name}/repo/
    echo
    # remove ppc64el from repo config and update repo
    sed -i s'/ppc64el //' ${dir_corp}/${dir_name}/repo/debian/conf/distributions
    pushd ${dir_corp}/${dir_name}/repo/debian/
      vi conf/distributions   # delete sid, if necessary
      reprepro -V --basedir . --delete clearvanished
      # remove the now missing entries from the sum files
      for sum in md5 sha1 sha256 sha512;do
        sed -i '/ppc64el/d' ${sum}sums.txt
      done
    popd

    # after creating the repo, copy it to ${dir_release}/repo-no-mgc
    case ${tree} in
      '5.5'|'10.0'|'bb-5.5-release'|'bb-10.0-release')
        echo "+ rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/repo/debian ${dir_release}/repo-no-mgc/${num}/"
                rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/repo/debian ${dir_release}/repo-no-mgc/${num}/
        ;;
    esac
    echo
  else
    line
    echo "+ Skipping Debian repo creation, as requested..."
    line
  fi

  #-------------------------------------------------------------------------------
  #  Create Ubuntu Repos
  #-------------------------------------------------------------------------------
  if [ "${create_ubuntu}" != "no" ]; then
    ## if the ubuntu repo dir exists, delete it
    #if [ -d ${dir_release}/${dir_name}/repo/ubuntu ]; then
    #  rm -rf "${dir_release}/${dir_name}/repo/ubuntu"
    #fi

    # trying updating the previous repo instead of creating a new one every time
    echo "+ rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/repo/ubuntu ${dir_release}/${dir_name}/repo/"
            rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/repo/ubuntu ${dir_release}/${dir_name}/repo/
    echo

    line
    echo "+ creating Ubuntu repos..."
    line

    # This is where the repository is actually updated
    if [ "${is_ent}" = "yes" ];then
      ${UBUNTU} ${incl_galera} ${is_ent} ubuntu ${dir_archive}/${tree}/build-${tarbuildnum} ${dir_archive_p8}/${tree}/${rev}
    else
      ${UBUNTU} ${incl_galera} ${is_ent} ubuntu ${dir_archive}/${tree}/build-${tarbuildnum} ${dir_archive_p8}/${tree}/${rev}
    fi

    # copy the repo to the corp release dir
    echo "+ rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/repo/ubuntu ${dir_corp}/${dir_name}/repo/"
            rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/repo/ubuntu ${dir_corp}/${dir_name}/repo/
    echo 
    # remove ppc64el from repo config and update repo
    sed -i s'/ppc64el //' ${dir_corp}/${dir_name}/repo/ubuntu/conf/distributions
    pushd ${dir_corp}/${dir_name}/repo/ubuntu/
      vi conf/distributions # remove deprecated distros
      reprepro -V --basedir . --delete clearvanished
      # remove the now missing entries from the sum files
      for sum in md5 sha1 sha256 sha512;do
        sed -i '/ppc64el/d' ${sum}sums.txt
      done
    popd

    # after creating the repo, copy it to ${dir_release}/repo-no-mgc
    case ${tree} in
      '5.5'|'10.0'|'bb-5.5-release'|'bb-10.0-release')
        echo "+ rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/repo/ubuntu ${dir_release}/repo-no-mgc/${num}/"
                rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/repo/ubuntu ${dir_release}/repo-no-mgc/${num}/
        ;;
    esac
    echo
  else
    line
    echo "+ Skipping Ubuntu repo creation, as requested..."
    line
  fi
  pushd ${dir_release}/${dir_name}
  echo

  #-------------------------------------------------------------------------------
  #  Create Yum Repos
  #-------------------------------------------------------------------------------
  if [ "${create_yum}" != "no" ]; then
    line
    echo "creating Yum repos..."
    line
    if [ -d ${dir_release}/${dir_name}/yum ]; then
      rm -rf "${dir_release}/${dir_name}/yum"
    fi

    # We can't create the yum dir on an nfs server, so we create it in our home
    # dir first
    # mkdir -v ${HOME}/yum

    echo "Before rsyncing the yum release..."

    shouldI display_the_previous_yum_directory

    shouldI exclude_an_old_release_from_the_yum_dir

    # Rsync a copy of the previous release to ${HOME}
    if [ "${exclude_release}" = "" ]; then
      rsync_wrapper "-av --delete-after ${dir_release}/mariadb-${prev_release}/yum ${HOME}/"
    else
      rsync_wrapper "-av --delete-after --exclude=*${exclude_release}* ${dir_release}/mariadb-${prev_release}/yum ${HOME}/"
    fi
    #echo "+ rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/yum ${HOME}/"
    #        rsync -a --info=progress2 --delete ${dir_release}/mariadb-${prev_release}/yum ${HOME}/
    echo

    pushd ${HOME}/yum
      # Run the yum script to create/update yum/dnf/zypp repos
      ${YUM} ${incl_galera} ${is_ent} ${dir_archive}/${tree}/build-${tarbuildnum} ${dir_archive_p8}/${tree}/${rev}
    popd

    # move the yum dir to where it needs to go
    echo "+ mv -i ${HOME}/yum ${dir_release}/${dir_name}/"
            mv -i ${HOME}/yum ${dir_release}/${dir_name}/
    pushd ${dir_release}/${dir_name}/

    # copy the yum dir to the corp release dir
    echo "+ copying the yum dir to the corp release dir"
    echo "+ rsync -a --info=progress2 --exclude=ppc64 --exclude=ppc64le --delete ${dir_release}/${dir_name}/yum ${dir_corp}/${dir_name}/"
            rsync -a --info=progress2 --exclude=ppc64 --exclude=ppc64le --delete ${dir_release}/${dir_name}/yum ${dir_corp}/${dir_name}/
    echo
    echo "+ remove ppc64 and ppc64le versions from corp release (if they were accidentally copied over)"
    pushd ${dir_corp}/${dir_name}/yum/
      rm -v *ppc64*
      rm -vrf */*/ppc64*
    popd

    # after creating the yum repo, copy it to ${dir_release}/yum-no-mgc (deleting
    # an old version beforehand, if one exists)
    if [ ! -d ${dir_release}/yum-no-mgc ]; then
      mkdir -vp ${dir_release}/yum-no-mgc
    fi
    if [ -d ${dir_release}/yum-no-mgc/${num} ]; then
      echo "+ rm -rf ${dir_release}/yum-no-mgc/${num}"
      rm -rf ${dir_release}/yum-no-mgc/${num}
    fi
    #echo "+ cp -ai ${dir_release}/${dir_name}/yum ${dir_release}/yum-no-mgc/${num}"
    #        cp -ai ${dir_release}/${dir_name}/yum ${dir_release}/yum-no-mgc/${num}
    case ${tree} in
      '5.5'|'10.0'|'bb-5.5-release'|'bb-10.0-release')
        echo "+ rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/yum ${dir_release}/yum-no-mgc/${num}"
                rsync -a --info=progress2 --delete ${dir_release}/${dir_name}/yum ${dir_release}/yum-no-mgc/${num}
        ;;
    esac
    echo
  else
    line
    echo "+ Skipping Yum repo creation, as requested..."
    line
  fi
fi

echo
echo
line
echo "+ done with repo creation for the ${version} release"
line
echo

shouldI create_package_tarballs

echo;echo;echo;echo

bundles

echo;echo;echo;echo

# now upload
shouldI upload_to_the_staging_mirror

echo;echo;echo;echo

shouldI copy_release_dir_to_corp_dir_so_corp_upload_is_smaller

echo;echo;echo;echo

shouldI upload_corp_dir_to_the_staging_mirror

echo;echo;echo;echo

shouldI upload_from_the_staging_mirror_to_the_primary_mirror

echo;echo;echo;echo

shouldI upload_from_the_staging_mirror_to_the_corp_mirror

echo;echo;echo;echo

shouldI upload_from_the_staging_mirror_to_the_yum_mirrors

echo;echo;echo;echo

shouldI activate_the_yum_repos

echo;echo;echo;echo

shouldI activate_the_deb_repos

echo;echo;echo;echo

shouldI activate_the_corp_repos

echo;echo;echo;echo

shouldI update_the_docker_mariadb_version

echo;echo;echo;echo

shouldI generate_the_file_list_pickle_for_org_downloads

echo;echo;echo;echo

echo "+ all done!"
echo;echo;echo;echo

# vim: filetype=sh
